Examples: 

 Input: arr[] = {3, 1, 3}
Output: Missing = 2, Repeating = 3
Explanation: In the array, 
2 is missing and 3 occurs twice 

Input: arr[] = {4, 3, 6, 2, 1, 1}
Output: Missing = 5, Repeating = 1

// There are many ways to solve this problem
// First Solution

//Time complexity : O(nlogn)
//space complexity :O(1)

#include <bits/stdc++.h>
using namespace std;

void findRepeatandMissing(int arr[], int n)
{
	//sort the array using built-in function or any sort method
	// O(logn)
	sort(arr, arr+n);
	
	
	int repeat = -1, missing = -1;
	// O(n) - single traversal
	for(int i=0; i<n; i++)
	{
		if(arr[i] != i+1) missing = i+1;
		
		if(i != arr[i]) repeat = arr[i];
	
	}
	
	cout << "Missing " << missing << " Repeating " << repeat ;
}

int main() {
	// your code goes here
	int arr[] =  {3, 1, 3};
	
	int n = sizeof(arr)/ sizeof(arr[0]);
	
	
	findRepeatandMissing(arr, n);
	
	return 0;
}


// Time complexity : O(n)
// space complexity : O(1)

#include <bits/stdc++.h>
using namespace std;

void findRepeatandMissing(int arr[], int n)
{
   // O(n) - traverse for repeating number by multiply -1 to a number
   // taking abs for negative number to positive then only we can identify the repeated no
   // -1 for taking index as 0
   for(int i=0; i<n; i++)
   {
   	if(arr[abs(arr[i]) - 1] > 0)
   	arr[abs(arr[i]) - 1] = -arr[abs(arr[i]) - 1];
   	
   	else
   	{
   		cout << "Repeating " << abs(arr[i]) << " ";
   		break;
   	}
   }
   
   // O(n) - traverse for missing number by checking positive values
   for(int i=0; i<n; i++)
   {
   	if(arr[i] > 0) {
   		cout << "Missing " << i+1 ;
   		break;
   	}
   }
   
   
}

int main() {
	// your code goes here
	int arr[] =  {3, 1, 3};
	
	int n = sizeof(arr)/ sizeof(arr[0]);
	
	
	findRepeatandMissing(arr, n);
	
	return 0;
}
